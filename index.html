<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Calculated Flight Deconfliction Schedule</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for a cleaner look */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f7f9;
        }
        .scrollable-table {
            max-height: 70vh;
            overflow-y: auto;
        }
    </style>
</head>
<body class="p-4 sm:p-8">
    <div class="max-w-6xl mx-auto bg-white shadow-xl rounded-xl p-6 lg:p-10">
        <h1 class="text-3xl font-extrabold text-gray-900 mb-6 border-b pb-2">Schedule Manager</h1>
        <p id="userIdDisplay" class="text-sm text-gray-500 mb-8"></p>

        <div class="flex flex-col sm:flex-row gap-4 mb-6 p-4 bg-gray-100 rounded-lg border border-gray-200">
            <div class="flex-grow">
                <label for="scheduleDate" class="block text-sm font-medium text-gray-700 mb-1">View Schedule For:</label>
                <input type="date" id="scheduleDate" class="p-2 border border-gray-300 rounded-lg w-full focus:ring-blue-500 focus:border-blue-500 bg-white">
            </div>
            <div class="flex items-end">
                <button id="sortRouteButton" class="w-full bg-gray-600 hover:bg-gray-700 text-white font-bold py-2.5 px-4 rounded-lg transition duration-150 shadow-md whitespace-nowrap">
                    Sort by Route
                </button>
            </div>
        </div>
        <div class="mb-10 p-6 bg-blue-50 rounded-lg border border-blue-200">
            <h2 class="text-xl font-semibold text-blue-800 mb-4">Pilot Input</h2>
            <form id="addFlightForm" class="space-y-4">
                <div class="grid grid-cols-1 md:grid-cols-4 gap-4">
                    <input type="text" id="flightId" required placeholder="Callsign (e.g., UA123)" class="p-3 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500">
                    
                    <input type="number" id="speedKnots" required placeholder="Speed (Knots, e.g., 350)" min="1" class="p-3 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500">
                    <select id="routeSelector" required class="p-3 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 bg-white">
                        <option value="" disabled selected>Select Route</option>
                        <option value="VR140">VR140</option>
                        <option value="VR142">VR142</option>
                        <option value="VR143">VR143</option>
                        <option value="IR123">IR123</option>
                        <option value="SR130">SR130</option>
                        <option value="SR286">SR286</option>
                        <option value="SR287">SR287</option>
                        <option value="SR290">SR290</option>
                        <option value="SR292">SR292</option>
                    </select>
                    <input type="datetime-local" id="startTime" required 
                            placeholder="Start Day/Time" 
                            class="p-3 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500">
                </div>
                
                <button type="submit" id="submitButton" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 rounded-lg transition duration-150 shadow-md">
                    Schedule Flight
                </button>
            </form>
        </div>
        <div id="messageBox" class="mt-4 p-4 rounded-lg hidden" role="alert"></div>

        <h2 class="text-xl font-semibold text-gray-900 mb-4">Current Flight Schedule</h2>
        <div class="scrollable-table shadow-lg rounded-lg border border-gray-200">
            <table class="min-w-full divide-y divide-gray-300">
                <thead class="sticky top-0 bg-gray-100 z-10">
                    <tr>
                        <th class="px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Time & Flight ID</th>
                        <th class="px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider hidden sm:table-cell">Route & Speed</th>
                        <th class="px-3 py-3 text-center text-xs font-medium text-gray-500 uppercase tracking-wider">Status / Conflict With</th>
                        <th class="px-3 py-3 text-center text-xs font-medium text-gray-500 uppercase tracking-wider">Actions</th>
                    </tr>
                </thead>
                <tbody id="scheduleBody" class="bg-white divide-y divide-gray-200">
                    </tbody>
            </table>
        </div>
    </div>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, deleteDoc, onSnapshot, collection, query, addDoc, setLogLevel, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        // --- Firebase Globals & DOM References ---
        let db;
        let auth;
        let userId = 'loading...';
        let appId;

        // Global state for all flights fetched from DB, and the currently displayed, processed list
        let dbFlights = []; 
        let flights = [];

        // State for filtering and sorting
        let selectedDate = new Date(); // Default to today
        let sortOrder = { key: 'startTime', direction: 'asc' }; // Default sort

        const form = document.getElementById('addFlightForm');
        const scheduleBody = document.getElementById('scheduleBody');
        const messageBox = document.getElementById('messageBox');
        const userIdDisplay = document.getElementById('userIdDisplay');
        const submitButton = document.getElementById('submitButton');
        const scheduleDateInput = document.getElementById('scheduleDate');
        const sortRouteButton = document.getElementById('sortRouteButton');


        // ######################################################################
        // ### DECONFLICTION ENGINE LOGIC (Equivalent to a separate JS file) ###
        // ######################################################################

        // Minimum separation time in milliseconds (5 minutes)
        const MIN_SEPARATION_MS = 5 * 60 * 1000;
        // WARNING threshold time in milliseconds (10 minutes) - NEW
        const WARNING_SEPARATION_MS = 10 * 60 * 1000;

        // DISTANCES (in Nautical Miles) for critical points
        const ROUTE_DISTANCES = {
            "VR140": [182, 240], 
            "VR142": [140, 178],
            "VR143": [0, 51, 322], // 0 to 322 is the full route length
            "IR123": [0, 71, 367], // 0 to 367 is the full route length
            "SR130": [50, 73, 109], // 50 to 109 is critical
            "SR286": [22, 66, 81, 111], // 66 to 111 is critical
            "SR287": [],
            "SR290": [43, 90, 120], // 43 to 120 is critical
            "SR292": [100, 114] // 100 to 114 is critical
        };


        /**
         * Converts a time value (string or Firestore Timestamp) to milliseconds for comparison.
         * @param {string | Object} timeValue - ISO format date/time string or Firestore Timestamp object.
         * @returns {number} Milliseconds since epoch, or 0 if invalid.
         */
        function getTimeInMs(timeValue) {
            if (timeValue && typeof timeValue.toDate === 'function') {
                // Handle Firestore Timestamp object (retrieved from DB)
                return timeValue.toDate().getTime();
            }
            // Handle ISO string (e.g., from intersectionTimes array or initial form input)
            const time = new Date(timeValue).getTime();
            return isNaN(time) ? 0 : time;
        }
        
        /**
         * Converts a Date object to a datetime-local string (YYYY-MM-DDTHH:MM).
         * @param {Date} date - The date object.
         * @returns {string} The formatted string.
         */
        function dateToDatetimeLocal(date) {
            const pad = (n) => (n < 10 ? '0' + n : n);
            return date.getFullYear() + '-' +
                   pad(date.getMonth() + 1) + '-' +
                   pad(date.getDate()) + 'T' +
                   pad(date.getHours()) + ':' +
                   pad(date.getMinutes());
        }
        /**
         * Calculates intersection times based on start time, speed, and route distances.
         * @param {string} startTimeString - The pilot's start date/time (datetime-local format).
         * @param {number} speedKnots - The airplane speed in knots (NM/hour).
         * @param {string} routeId - The key for the selected route in ROUTE_DISTANCES.
         * @returns {Array<string>} An array of calculated intersection times (datetime-local strings).
         */
        function calculateIntersectionTimes(startTimeString, speedKnots, routeId) {
            const distances = ROUTE_DISTANCES[routeId];
            if (!distances || speedKnots <= 0) return [];
            const startMs = new Date(startTimeString).getTime();
            const calculatedTimes = [];
            distances.forEach(distanceNM => {
                // Time (hours) = Distance (NM) / Speed (Knots)
                const timeHours = distanceNM / speedKnots;
                
                // Time (milliseconds) = Time (hours) * 60 min/hr * 60 sec/min * 1000 ms/sec
                const timeMs = timeHours * 3600 * 1000;
                // Calculated intersection time in milliseconds
                const intersectionTimeMs = startMs + timeMs;
                
                // Convert back to datetime-local string format
                const intersectionDate = new Date(intersectionTimeMs);
                calculatedTimes.push(dateToDatetimeLocal(intersectionDate));
            });
            
            return calculatedTimes;
        }

        /**
         * Marks two flights as conflicting by adding details of the opposing flight
         * to the `conflictsWith` array.
         */
        function MarkConflict(flight1, flight2){
            const conflictDetails1 = {
                id: flight2.id,
                flightId: flight2.flightId,
                routeId: flight2.routeId
            };
            const conflictDetails2 = {
                id: flight1.id,
                flightId: flight1.flightId,
                routeId: flight1.routeId
            };

            // Update flight A status
            flight1.status = 'CONFLICT';
            if (!flight1.conflictsWith) flight1.conflictsWith = [];

            // Prevent duplicate conflict entries
            if (!flight1.conflictsWith.some(c => c.id === flight2.id)) {
                flight1.conflictsWith.push(conflictDetails1);
            }

            // Update flight B status
            flight2.status = 'CONFLICT';
            if (!flight2.conflictsWith) flight2.conflictsWith = [];

            // Prevent duplicate conflict entries
            if (!flight2.conflictsWith.some(c => c.id === flight1.id)) {
                flight2.conflictsWith.push(conflictDetails2);
            }
        }
        
        /**
         * Marks two flights as warning by adding details of the opposing flight
         * to the `warningsWith` array. - NEW FUNCTION
         */
        function MarkWarning(flight1, flight2) {
            // Only mark as WARNING if not already marked as CONFLICT
            if (flight1.status !== 'CONFLICT') {
                flight1.status = 'WARNING';
            }
            if (flight2.status !== 'CONFLICT') {
                flight2.status = 'WARNING';
            }
            
            const warningDetails1 = {
                id: flight2.id,
                flightId: flight2.flightId,
                routeId: flight2.routeId
            };
            const warningDetails2 = {
                id: flight1.id,
                flightId: flight1.flightId,
                routeId: flight1.routeId
            };

            if (!flight1.warningsWith) flight1.warningsWith = [];
            if (!flight2.warningsWith) flight2.warningsWith = [];

            // Prevent duplicate warning entries
            if (!flight1.warningsWith.some(c => c.id === flight2.id)) {
                flight1.warningsWith.push(warningDetails1);
            }
            if (!flight2.warningsWith.some(c => c.id === flight1.id)) {
                flight2.warningsWith.push(warningDetails2);
            }
        }

        /**
         * Helper function to determine if two time windows overlap by less than MIN_SEPARATION_MS.
         * @param {string} in1 - Entry time for window 1.
         * @param {string} out1 - Exit time for window 1.
         * @param {string} in2 - Entry time for window 2.
         * @param {string} out2 - Exit time for window 2.
         * @returns {boolean} True if a conflict exists.
         */
        function checkOverlap(in1, out1, in2, out2) {
            const timein1 = getTimeInMs(in1);
            const timeout1 = getTimeInMs(out1);
            const timein2 = getTimeInMs(in2);
            const timeout2 = getTimeInMs(out2);

            // Time Separation Check (5-minute rule)
            // Conflict exists if the time interval intersection is less than MIN_SEPARATION_MS.

            // Check if intervals overlap
            const overlapStartsBefore = timein1 < timeout2;
            const overlapEndsAfter = timeout1 > timein2;

            if (overlapStartsBefore && overlapEndsAfter) {
                // For deconfliction, we check if the critical windows intersect at all (time overlap).
                const areWindowsOverlapping = (timein1 < timeout2) && (timeout1 > timein2);

                if (areWindowsOverlapping) {
                    // Let's stick to the principle: if the critical windows overlap in time, it's a CONFLICT.
                    return true;
                }
            }
            return false;
        }
        
        /**
         * Checks if two critical windows are within WARNING_SEPARATION_MS of each other (10 minutes). - NEW FUNCTION
         * This applies when the windows do NOT overlap (i.e., not a CONFLICT), but are close.
         * @param {string} in1 - Entry time for window 1.
         * @param {string} out1 - Exit time for window 1.
         * @param {string} in2 - Entry time for window 2.
         * @param {string} out2 - Exit time for window 2.
         * @returns {boolean} True if a warning exists.
         */
        function checkWarningProximity(in1, out1, in2, out2) {
            const timein1 = getTimeInMs(in1);
            const timeout1 = getTimeInMs(out1);
            const timein2 = getTimeInMs(in2);
            const timeout2 = getTimeInMs(out2);

            // Check for NO OVERLAP
            const noOverlap = (timeout1 <= timein2) || (timeout2 <= timein1);
            
            if (noOverlap) {
                // Separation time is the time between the end of the first and the start of the second.
                let separation = 0;
                if (timeout1 <= timein2) {
                    // Flight 1 ends, then Flight 2 starts
                    separation = timein2 - timeout1;
                } else {
                    // Flight 2 ends, then Flight 1 starts
                    separation = timein1 - timeout2;
                }

                // If separation is positive (no overlap) and less than WARNING_SEPARATION_MS, it's a WARNING
                return separation > 0 && separation < WARNING_SEPARATION_MS;
            }

            return false;
        }

        /**
         * Normalizes the critical time window for a given flight based on its route.
         * @param {Object} flight - The flight object.
         * @returns {Array<string>} An array [entryTime, exitTime].
         */
        function getCriticalTimes(flight) {
            const times = flight.intersectionTimes;
            switch (flight.routeId) {
                // Rule 1, 2, 4, 6, 7, 9 (Specific Segments)
                case "VR140": return [times[0], times[1]]; // 182 NM to 240 NM
                case "VR142": return [times[0], times[1]]; // 140 NM to 178 NM
                case "SR130": return [times[0], times[2]]; // 50 NM to 109 NM
                case "SR290": return [times[0], times[2]]; // 43 NM to 120 NM
                case "SR292": return [times[0], times[1]]; // 100 NM to 114 NM

                // Rule 3, 5 (Full/Long Segments)
                case "VR143": return [times[0], times[2]]; // 0 NM to 322 NM (full route)
                case "IR123": return [times[0], times[2]]; // 0 NM to 367 NM (full route)
                case "SR286": return [times[1], times[3]]; // 66 NM to 111 NM
                default: return [];
            }
        }

        /**
         * Core logic to check for conflicts against all flights in the provided list.
         * @param {Array<Object>} flightsList - The complete list of flights from the database.
         * @returns {Array<Object>} - A new array of flights with live 'status', 'conflictsWith', and 'warningsWith' added.
         */
        function getLiveSchedule(flightsList) {
            // Create a working copy, resetting conflict/warning state
            const liveSchedule = flightsList.map(f => ({ 
                ...f, 
                status: 'OK', 
                conflictsWith: [], // {id, flightId, routeId}
                warningsWith: [] // NEW
            }));

            for (let i = 0; i < liveSchedule.length; i++) {
                for (let j = i + 1; j < liveSchedule.length; j++) {
                    const flightA = liveSchedule[i];
                    const flightB = liveSchedule[j];

                    if(flightA.routeId === "SR287" || flightB.routeId === "SR287") {
                        continue;
                    }

                    // --- 1. Same-Route Separation Check (MIN_SEPARATION_MS = CONFLICT) ---
                    if (flightA.routeId === flightB.routeId) {
                        const timeA = getTimeInMs(flightA.startTime);
                        const timeB = getTimeInMs(flightB.startTime);
                        const separation = Math.abs(timeA - timeB);
                        
                        // Check for CONFLICT (less than 5 minutes)
                        if (separation < MIN_SEPARATION_MS) {
                            MarkConflict(flightA, flightB);
                        } 
                        // NEW: Check for WARNING (less than 10 minutes, but not a conflict)
                        else if (separation < WARNING_SEPARATION_MS) {
                             MarkWarning(flightA, flightB);
                        }
                    }

                    // --- 2. Different-Route Intersection Conflict/Warning Check (9 Rules) ---
                    if (flightA.routeId !== flightB.routeId) {

                        const checkRoutePair = (f1, f2) => {
                            const routePair = [f1.routeId, f2.routeId].sort().join('-');
                            return (
                                routePair === 'SR130-VR140' || // Rule 1
                                routePair === 'SR290-VR142' || // Rule 2
                                routePair === 'SR286-VR142' || // Rule 3
                                routePair === 'SR130-VR143' || // Rule 4
                                routePair === 'IR123-VR143' || // Rule 5
                                routePair === 'IR123-SR130' || // Rule 6
                                routePair === 'SR286-SR290' || // Rule 7
                                routePair === 'SR286-SR292' || // Rule 8
                                routePair === 'SR290-SR292'    // Rule 9
                            );
                        };

                        if (checkRoutePair(flightA, flightB)) {
                            const timesA = getCriticalTimes(flightA);
                            const timesB = getCriticalTimes(flightB);
                            
                            if (timesA.length !== 2 || timesB.length !== 2) continue;

                            // ** CONFLICT Check: Check for critical window overlap **
                            if (checkOverlap(timesA[0], timesA[1], timesB[0], timesB[1])) {
                                MarkConflict(flightA, flightB);
                            }
                            // ** WARNING Check: Check for critical windows within 10 minutes, only if not already a conflict **
                            else if (checkWarningProximity(timesA[0], timesA[1], timesB[0], timesB[1])) {
                                MarkWarning(flightA, flightB);
                            }
                        }
                    }
                }
            }
            return liveSchedule;
        }

        // ######################################################################
        // ### END OF DECONFLICTION ENGINE LOGIC ################################
        // ######################################################################

        /**
         * Displays a temporary message to the user (e.g., success or error).
         */
        function showMessage(message, type = 'success') {
            messageBox.textContent = message;
            messageBox.classList.remove('hidden', 'bg-green-100', 'text-green-800', 'bg-red-100', 'text-red-800');
            if (type === 'success') {
                messageBox.classList.add('bg-green-100', 'text-green-800');
            } else if (type === 'error') {
                messageBox.classList.add('bg-red-100', 'text-red-800');
            }
            setTimeout(() => {
                messageBox.classList.add('hidden');
            }, 5000);
        }

        /**
         * Applies the current date filter and sorting, then calculates conflicts and re-renders.
         */
        function processAndRenderFlights() {
            // --- 1. Filter for Selected Date's Flights ---
            const targetDate = new Date(selectedDate);
            targetDate.setHours(0, 0, 0, 0); 
            const nextDay = new Date(targetDate);
            nextDay.setDate(nextDay.getDate() + 1); 

            let displayFlights = dbFlights.filter(f => {
                if (!f.startTime || typeof f.startTime.toDate !== 'function') return false;
                const flightDate = f.startTime.toDate();
                const flightTimeMs = flightDate.getTime();

                // Filter to include flights only within the 24-hour window of the selected date
                return flightTimeMs >= targetDate.getTime() && flightTimeMs < nextDay.getTime();
            });

            // --- 2. Sort Flights ---
            displayFlights.sort((a, b) => {
                if (sortOrder.key === 'startTime') {
                    const timeA = getTimeInMs(a.startTime);
                    const timeB = getTimeInMs(b.startTime);
                    const result = timeA - timeB;
                    return sortOrder.direction === 'asc' ? result : -result;
                } else if (sortOrder.key === 'routeId') {
                    const routeA = a.routeId.toLowerCase();
                    const routeB = b.routeId.toLowerCase();
                    if (routeA < routeB) return sortOrder.direction === 'asc' ? -1 : 1;
                    if (routeA > routeB) return sortOrder.direction === 'asc' ? 1 : -1;
                    return 0;
                }
                return 0;
            });

            // --- 3. Calculate Live Conflict Status ---
            flights = getLiveSchedule(displayFlights);

            // --- 4. Re-render the table ---
            renderSchedule();
        }

        /**
         * Renders the flight table based on the current 'flights' array (which includes live status).
         */
        function renderSchedule() {
            scheduleBody.innerHTML = ''; // Clear existing rows

            if (flights.length === 0) {
                const dateDisplay = selectedDate.toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' });
                scheduleBody.innerHTML = `
                    <tr>
                        <td colspan="5" class="px-3 py-4 text-center text-gray-500 italic">
                            No flights scheduled for ${dateDisplay}. Add one above!
                        </td>
                    </tr>
                `;
                return;
            }
            flights.forEach(flight => {
                const isConflict = flight.status === 'CONFLICT';
                const isWarning = flight.status === 'WARNING' && !isConflict; // Only show warning if not a conflict
                
                let rowClass = 'bg-white hover:bg-gray-50';
                let statusBadgeClass = 'bg-green-100 text-green-800';
                let conflictText = 'â€”';
                let conflictTextColor = 'text-gray-500';

                if (isConflict) {
                    rowClass = 'bg-red-100 hover:bg-red-200';
                    statusBadgeClass = 'bg-red-500 text-white';
                    if (flight.conflictsWith.length > 0) {
                        const ids = flight.conflictsWith.map(c => `${c.flightId} (${c.routeId})`);
                        conflictText = `vs ${ids.slice(0, 3).join(', ')}${ids.length > 3 ? '...' : ''}`;
                        conflictTextColor = 'text-red-700';
                    }
                } else if (isWarning) {
                    // NEW: Warning styles
                    rowClass = 'bg-yellow-50 hover:bg-yellow-100';
                    statusBadgeClass = 'bg-yellow-500 text-black';
                    if (flight.warningsWith.length > 0) {
                        const ids = flight.warningsWith.map(c => `${c.flightId} (${c.routeId})`);
                        conflictText = `vs ${ids.slice(0, 3).join(', ')}${ids.length > 3 ? '...' : ''}`;
                        conflictTextColor = 'text-yellow-700';
                    }
                }

                const
